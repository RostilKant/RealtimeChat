## LAB 5

ASP.NET Core Identity was used for user authentication. It is using PBKDF2 - Password-Based Key Derivation Function 2.  

Advantages of using PBKDF2:                                                                                                                                       
- Strong hash algoritm - HMAC-SHA256
- Random 128-bit salt for each hash, generated by secure RNG
- Adding iterations(default 10 000), which make algoritm "future-proof"

Also I'll force users to use more complicated passwords by changing configuration for password requirements:

                options.Password.RequireDigit = true;
                options.Password.RequireLowercase = true;
                options.Password.RequireUppercase = true;
                options.Password.RequireNonAlphanumeric = true;
                options.Password.RequiredLength = 10;
                options.User.RequireUniqueEmail = true;


## LAB 6
In this lab I used Data Protection API for encrypting sensitive data and storing in db.                                                                          By default it is using AES-256-CBC for confidentiality and HMACSHA256 for authenticity.A 512-bit master key, changed every 90 days, is used to derive the two sub-keys used for these algorithms. 

      services.AddDataProtection()
                .PersistKeysToFileSystem(new DirectoryInfo(@"bin/Debug/keys/"))
                .UseCryptographicAlgorithms(
                    new AuthenticatedEncryptorConfiguration()
                    {
                        EncryptionAlgorithm = EncryptionAlgorithm.AES_256_CBC,
                        ValidationAlgorithm = ValidationAlgorithm.HMACSHA256
                    });

Key for AES is stored local on machine(projectFolder/bin/Debug/keys/someSymbolsAndNumbers.xml)

      <?xml version="1.0" encoding="utf-8"?>
      <key id="47b8dda1-231d-4137-9507-260bbae6bbfa" version="1">
            <creationDate>2020-12-12T02:41:21.5560337Z</creationDate>
            <activationDate>2020-12-12T02:41:21.5449987Z</activationDate>
            <expirationDate>2021-03-12T02:41:21.5449987Z</expirationDate>
            <descriptor deserializerType="Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AuthenticatedEncryptorDescriptorDeserializer, Microsoft.AspNetCore.DataProtection, Version=3.1.10.0, Culture=neutral, PublicKeyToken=adb9793829ddae60">
            <descriptor>
                  <encryption algorithm="AES_256_CBC" />
                  <validation algorithm="HMACSHA256" />
                  <masterKey p4:requiresEncryption="true" xmlns:p4="http://schemas.asp.net/2015/03/dataProtection">
                  <!-- Warning: the key below is in an unencrypted form. -->
                  <value>EwhEEaLnZjlYqI7hPWJklzY/dWkXqjei0NYuo3VGbJgpMYrD3UmECrkCPlRpbYnZ2Ll4sQSV0N9WKdYqE9NYZQ==</value>
                  </masterKey>
            </descriptor>
            </descriptor>
      </key>

## LAB 7
Adding self-signed cert for enabling https on server.                                                                                
At first I created config for openssl.

      [req]
      default_bits = 2048
      prompt = no
      default_md = sha256
      x509_extensions = v3_req
      distinguished_name = dn

      [dn]
      C = UA
      ST = Kyiv
      L = Rose
      O = Security
      OU = Rose Security Department
      emailAddress = balgas92@gmail.com
      CN = localhost

      [v3_req]
      subjectAltName = @alt_names

      [alt_names]
      DNS.1 = localhost
      DNS.2 = *.localhost
      

Command for generating cert with key: **openssl req -newkey rsa:2048 -x509 -nodes -keyout server0.key -new -out server0.crt -config openssl-custom.cnf -days 365** 

After that should be created .pfx file, that contains both key and cert. It is needed for Kestrel server to connect via https.                                     In user secrets was added new section with all corresponding fields (path to .pfx and pass)

image here

Command for creating .pfx: **openssl pkcs12 -export -out server0.pfx -inkey server0.key -in server0.crt -passin pass:keyServer -passout pass:pfxServer**
-passin: password for encrypting .key; -passout: password for encrypting .pfx; 

Image here

As I am using linux, it should trust this cert, so at first I copy cert to **/usr/local/share/ca-certs**, then run **sudo update-ca-certificates** and after that I should check /etc/ssl/certs for .pm for my cert, that was generated. After that **openssl verify cert.crt** for checking if cert is trusted. Also, if we want to achieve 'lock' picture in the chrome, we can use certutil for adding cert to chrome db:                                                                       **certutil -d sql:$HOME/.pki/nssdb -A -t "C,," -n "Rostil0" -i /home/rostil/Programming/ASP\ .NET\ Core/RealtimeChat/ssl/server0.crt**

For adding cert for Angular I changed angular.json and add such properties:                               
"ssl": true,                                                                              
"sslCert": "/home/rostil/Programming/ASP .NET Core/RealtimeChat/ssl/server0.crt",                                       
"sslKey": "/home/rostil/Programming/ASP .NET Core/RealtimeChat/ssl/server0.key"
      
